# practica_pygame2
sesion 4
1.sesion4_ejemplo1 Este ejercicio consiste en modificar un programa básico para que un círculo que rebota en los bordes aumente su velocidad horizontal cada vez que ocurre un rebote. Cada impacto con un límite debe incrementar la variable de velocidad en 0.1 unidades. Además, se debe utilizar pygame.time.Clock para asegurar que la animación se ejecute a una tasa constante de 60 fotogramas por segundo.
2.sesion4_ejejmplo2 En este ejercicio se debe crear una animación en la que un círculo aumente y disminuya su tamaño de manera continua, alternando su radio entre 20 y 50 píxeles. Cuando el círculo alcance cualquiera de los dos límites del tamaño, debe invertirse la dirección del cambio del radio para simular un efecto de pulsación.
3. sesion4_ejemplo3 Este ejercicio requiere implementar una simulación sencilla de gravedad. Un círculo debe caer aplicando una aceleración vertical constante de 0.5 por cada fotograma. Al tocar el suelo, debe rebotar, pero con pérdida de energía: su velocidad vertical debe reducirse en un 20% al momento del impacto. El movimiento debe repetirse mientras el círculo continúe rebotando.

sesion 5
1.En este ejercicio se debe modificar el programa base para permitir que el usuario cambie el tamaño de una imagen mediante las teclas + y -. Al modificar el tamaño, es necesario conservar la proporción original de la imagen para evitar distorsiones visibles, ajustando el escalado de forma uniforme. El archivo correspondiente debe guardarse con el nombre sesion5_ej1.py.
2.Este ejercicio requiere cargar una hoja de sprites que contenga al menos cuatro fotogramas, como los de un personaje realizando una caminata. La animación debe reproducirse alternando los frames cada 100 milisegundos, creando un efecto fluido de movimiento. Se pueden emplear recursos gráficos obtenidos de opengameart.org o elaborados manualmente. El archivo debe guardarse bajo el nombre sesion5_ej2.py.
3.El mini–proyecto de esta sesión consiste en crear un programa en el que una imagen, como una nave, se oriente dinámicamente en dirección al puntero del ratón o a un joystick. Además, la imagen debe avanzar hacia adelante cuando el usuario presione una tecla específica. Es fundamental ajustar su tamaño usando pygame.transform.scale para asegurar una visualización adecuada. Este trabajo debe guardarse como sesion5_mini.py, y la entrega debe incluir tanto el código fuente como la imagen utilizada.

sesion 6
1.Este ejercicio consiste en modificar el programa base para que el rectángulo que representa al jugador cambie de color al detectar una colisión con el objetivo. Cuando ambos objetos se superponen, el rectángulo debe adoptar un color distinto, como verde, para indicar visualmente el contacto. El archivo correspondiente debe guardarse como sesion6_ej1.py.
2.En este ejercicio se debe desarrollar un programa en el cual el jugador controle un rectángulo que debe moverse para recolectar círculos generados en posiciones aleatorias mediante el uso de random.randint. Cada vez que el jugador recolecta un círculo, otro debe aparecer inmediatamente en una nueva ubicación, y además debe mostrarse en pantalla un contador actualizado que indique la cantidad total de objetos recolectados. El archivo final debe guardarse como sesion6_ej2.py.
3.Este ejercicio requiere diseñar un programa en el que el jugador deba evitar colisionar con obstáculos móviles, representados típicamente por círculos que se desplazan, por ejemplo, de forma horizontal. El jugador controla un rectángulo y, en caso de que se produzca una colisión con alguno de los obstáculos, el juego debe finalizar o reiniciarse según el comportamiento programado. El archivo correspondiente debe guardarse como sesion6_ej3.py.
4.El mini–proyecto de la sesión consiste en desarrollar un juego sencillo en el que un sprite —como el de una nave— pueda ser controlado mediante el teclado o un control externo. El jugador deberá recolectar objetos para sumar puntos y, simultáneamente, evitar obstáculos. El programa debe mostrar un contador de puntos ya sea en la terminal o directamente en la pantalla utilizando pygame.font. Debe guardarse como sesion6_mini.py, y la entrega final debe incluir tanto el código fuente como los recursos gráficos empleados.
